class Solution {
  public:
    string findOrder(vector<string> &words) {
        unordered_map<char,vector<char>>graph;
        unordered_map<char,int>indegree;
        for(auto &w:words){
            for(auto c:w){
                indegree[c]=0;
            }
        }
        for(int i=0;i<words.size()-1;i++){
           
            string s1=words[i];
            string s2=words[i+1];
            int len=min(s1.size(),s2.size());
            bool found=false;
            for(int j=0;j<len;j++){
                if (s1[j] != s2[j]){
                graph[s1[j]].push_back(s2[j]);
                indegree[s2[j]]++;
                found=true;
                break;
                }
            }
            if(!found && s1.size()>s2.size())
            return "";
            
        }
        
        queue<char>q;
        string ans;
        for(auto &p :indegree){
            if(p.second==0){
                q.push(p.first);
            }
        }
        while(!q.empty()){
            char c=q.front();
            q.pop();
            ans+=c;
            for(auto n :graph[c]){
                indegree[n]--;
                if(indegree[n]==0){
                    q.push(n);
                }
            }
            
        }
        return ans.size()==indegree.size()?ans:"";
        
        
        
    }
};
