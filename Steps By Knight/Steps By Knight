class Solution {
  public:
    bool valid(int i,int j,int n){
            return i>=0 &&j>=0&&i<n&&j<n;
        }
    int minStepToReachTarget(vector<int>& knightPos, vector<int>& targetPos, int n) {
       int row[8] = {-2,-2,-1,-1,1,1,2,2};
       int col[8] = {-1,1,-2,2,-2,2,-1,1};
        knightPos[0]--;
        knightPos[1]--;
        targetPos[0]--;
        targetPos[1]--;
        if(targetPos[0]==knightPos[0] &&targetPos[1]==knightPos[1])
        
        return 0;
        
        queue<pair<int,int>>q;
        vector<vector<bool>>chess(n,vector<bool>(n,0));
        q.push({knightPos[0],knightPos[1]});
        chess[knightPos[0]][knightPos[1]]=1;
        int step=0;
        while(!q.empty()){
            int count=q.size();
            while(count--){
                int i=q.front().first;
                int j=q.front().second;
                q.pop();
                for(int k=0;k<8;k++){
                    int newi=i+row[k];
                    int newj=j+col[k];
                    if(valid(newi,newj,n)&&! chess[newi][newj]){
                        if(newi==targetPos[0] &&newj==targetPos[1])
                        return step+1; 
                        chess[newi][newj]=1;
                        q.push({newi,newj});
                    }
                }
            }
            step++;
            
        }
        return -1;
    }
};
