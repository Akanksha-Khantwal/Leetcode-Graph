class Solution {
  public:
   int findpar(int u,vector<int>&par){
       if(u==par[u]){
           return u ;
       }
       return par[u]=findpar(par[u],par);
       //path compression
   }
   void unionbyrank(int u,int v,vector<int>&par,vector<int>&rank){
       int pu=findpar(u,par);
       int pv=findpar(v,par);
       if(rank[pu]>rank[pv]){
           par[pv]=pu;
       }
       else if(rank[pu]<rank[pv]){
           par[pu]=pv;
       }
       else{
           par[pv]=pu;
           rank[pu]++;
       }
   }
    int spanningTree(int V, vector<vector<int>>& edges) {
        vector<vector<pair<int,int>>>adj(V);
        for(int i=0;i<edges.size();i++){
            int u=edges[i][0];
            int v=edges[i][1];
            int w=edges[i][2];
            adj[u].push_back({v,w});
            adj[v].push_back({u,w});
        }
        vector<int>par(V);
        vector<int>rank(V,0);
        for(int i=0;i<V;i++){
            par[i]=i;
        }
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>p;
        for(int i=0;i<V;i++){
            for(int j=0;j<adj[i].size();j++){
                p.push({adj[i][j].second,{i,adj[i][j].first}});
            }
        }
        int cost=0;
        int edge=0;
        while(!p.empty()){
            int w=p.top().first;
            int u=p.top().second.first;
            int v=p.top().second.second;
            p.pop();
            
            if(findpar(u,par)!=findpar(v,par)){
                cost+=w;
                unionbyrank(u,v,par,rank);
                edge++;
            }
            if(edge==V-1){
                break;
            }
        }
       return cost; 
       
    }
};
